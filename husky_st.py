from bittrex import Bittrex
bitty = Bittrex(" ", " ")
import time, json, datetime, siberian


def arbitage_loop():
    currencylist = ['LTC', 'DASH', 'XMR', 'DGB', 'BTS', 'XRP', 'XEM', 'XLM', 'FCT', 'DGD', 'WAVES', 'ETC', 'STRAT',
                    'SNGLS', 'REP', 'NEO', 'ZEC', 'TIME', 'GNT', 'LGD', 'TRST', 'WINGS', 'RLC', 'GNO', 'GUP', 'LUN',
                    'TKN', 'HMQ', 'ANT', 'SC', 'BAT', '1ST', 'QRL', 'CRB', 'PTOY', 'MYST', 'CFI', 'BNT', 'NMR', 'SNT',
                    'MCO', 'ADT', 'FUN', 'PAY', 'MTL', 'STORJ', 'ADX', 'OMG', 'CVC', 'QTUM', 'BCC']
    #liquidity_asset, liquidity_bal = init_liquidity_asset()
    while True:
        for curr in currencylist:
            liquidity_asset, liquidity_bal = init_liquidity_asset()
            result, depth, rate, rate2 = evaluate_tx(curr,liquidity_asset, liquidity_bal)
            if result > liquidity_bal:
                print(curr, "after: ", result, "\n", depth, liquidity_asset, rate)
                liquidity_asset = put_ask(curr, depth, liquidity_asset, rate, rate2)
                if liquidity_asset == "timeout":
                    print("timeout, open order has not been filled")
                    break



def evaluate_tx(curr, liquidity_asset, bal):
    ask_in_eth = siberian.ask("ETH-"+curr)*TOLERANCE()
    bid_in_eth = siberian.bid("ETH-"+curr)*TOLERANCE()
    ask_btc_eth = siberian.ask("BTC-ETH")
    bid_btc_eth = siberian.bid("BTC-ETH")
    ask_in_btc = siberian.ask("BTC-"+curr)*TOLERANCE()
    bid_in_btc = siberian.bid("BTC-"+curr)*TOLERANCE()


    if liquidity_asset == "BTC":
        buy_depth_at_price = (bal / ask_in_btc) * BITTREX_FEE()
        sell_result = buy_depth_at_price * bid_in_eth * BITTREX_FEE()
        result_in_terms_of_liquidity_asset = sell_result * ask_btc_eth
        print(curr + ": You end up with this many ETH: " + str(sell_result) + ". Which is equal to this many BTC: " + str(result_in_terms_of_liquidity_asset)+". Starting with "+ str(bal) + " BTC.")
        return (result_in_terms_of_liquidity_asset, buy_depth_at_price, ask_in_btc, bid_in_eth)

    elif liquidity_asset == "ETH":
        buy_depth_at_price = (bal / ask_in_eth) * BITTREX_FEE()
        sell_result = buy_depth_at_price * bid_in_btc * BITTREX_FEE()
        result_in_terms_of_liquidity_asset = sell_result / bid_btc_eth
        print(curr + " You end up with this many BTC: " + str(sell_result) + ". Which is equal to this many ETH: " + str(result_in_terms_of_liquidity_asset)+". Starting with "+ str(bal) + " ETH.")
        return(result_in_terms_of_liquidity_asset, buy_depth_at_price, ask_in_eth, bid_in_btc)

def TOLERANCE():
    #(0,1) the leeway allowed when calculating profitability, the closer to 1 the higher chance of orders not being filled
    return(.999)

def put_ask(curr, depth, asset, price, price2):
    """Constructs a set of orders with the hopes of increasing dollar amount

    This function can be a bit difficult to wade through, but the premise is that we call it once we determine that a
    trade should be profitable(evaluate_tx), it puts in an order with the values given to it. It waits to see if the
    order can be quickly filled, if not it cancels the order. Hopefully it does actually fill, in which case we change
    the asset variable, get the balance of that alt we converted to, and put in an order for either ETH or BTC, the
    opposite of what we had in the beginning. This order has a time limit of ten minutes after which the program times
    out.

    curr: a string such as "VTC" denoting the altcoin involved in this trade
    depth: The amount of altcoin to originally purchase in the first transaction, should be generated by evaluate_tx()
    asset: either BTC or ETH, whichever we are converting FROM, init_liquidity_asset() handles this
    price: the price for transaction1, evaluate_tx() should provide this
    price2: the price of transaction2, evaluate_tx() should provide this
    """
    #Transaction 1
    bitty.buy_limit(asset+"-"+curr, depth, price)
    time.sleep(30) #wait for network latency
    wait = 0
    while wait < 15:
        oList = bitty.get_open_orders(asset + "-" + curr)['result']
        if oList: #if there are orders open, wait until 15
            wait += 1
            print("Alt order outstanding")
        else:#order is filled, switch liquidity assets
            if asset == "BTC":
                asset = "ETH"
            if asset == "ETH":
                asset = "BTC"
            break
        time.sleep(1)
    if wait == 15: #if it's been 15 seconds and the order is not filled, cancel it
        for o in oList:
            orderId = o['OrderUuid']
        bitty.cancel(orderId)
        return(asset) #back to searching
    else:
        #Transaction 2
        depth_to_main = bitty.get_balance(curr)  # gets exact balance of the altcoin, including dust
        bitty.sell_limit(asset + "-" + curr, depth_to_main, price2)
        time.sleep(30)#wait for latency
        wait = 0
        while wait < 600: #wait ten minutes
            oList = bitty.get_open_orders(asset + "-" + curr)['result']
            print(oList)
            if oList:
                wait += 1
                print("Main order outstanding")
            else:
               return(asset)
            time.sleep(5)
        if wait == 600:
            return("timeout")


def BITTREX_FEE():
    return(.9975)

def init_liquidity_asset():
    eth_bal = bitty.get_balance("ETH")['result']['Balance']
    btc_bal = bitty.get_balance("BTC")['result']['Balance']
    if eth_bal > btc_bal:
        return("ETH", eth_bal)
    if eth_bal < btc_bal:
        return("BTC", btc_bal)
    else:
        return(None)

def main():
    arbitage_loop()

if __name__ == "__main__":
    main()